---
title: "Island Biogeography Shapes Fruit-frugivore Interactions"
subtitle: 'Mauro Galetti, Andrés F. Ramírez-Mejía, Haruko Ando, Seheno Andriantsaralaza, Cláudia Baider, Julia Ball, Mayara Guimarães Beltrão, Jedediah Brodie, Rafael Silveira Bueno, Maria Guerrero Campos, Daiane Cristina Carreira, Juliana Cordeiro, Sara Dalton, Bo Dalsgaard, Isabel Donoso, Donald R. Drake, Nik Fadzly bin Nik Rosely, Patricia dos Santos Ferreira, Noemí Matías Ferrer, F. B. Vincent Florens, Francisco E. Fontúrbel, Sara M. E. Gabrielson, Juan Esteban Martínez Gómez, Fernando Gonçalves, Christopher Kaiser-Bunbury, Katerina Sam, Seokmin Kim, Laís Lautenschlager, Shawn J. Leroux, Alba Costa Lorenzo, Hannah Madden, Kim McConkey, Félix M. Medina, Jayasilan Mohd-Azlan, Raquel Muñoz-Gallego, Manuel Nogales, Eva K. Nóbrega, Renske E. Onstein, José Ignacio Orellana, Ana Filipa Palmeirim, Roberto Resendes, Ricardo Rocha, Chanpen Saralamba, Elise Sivault, Tuanjit Sritongchuay, Fabio Tarazona, Maria da Anunciação Mateus Ventura, Jeferson Vizentin-Bugoni, Maximilian Vollstädt, Kenta Watanabe, Xue Xiao, Anna Traveset'
author: "Supporting Information S1. Journal PNAS"
format:
  docx: 
    include-in-header:
      text: |
        \renewcommand{\thesection}{S\arabic{section}}
        \renewcommand{\thesubsection}{S\arabic{section}.\arabic{subsection}}
        \renewcommand{\thefigure}{S\arabic{figure}}
        \renewcommand{\thetable}{S\arabic{table}}
        \usepackage{fvextra}
        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{
          fontsize=\footnotesize,
          baselinestretch=0.8,
          commandchars=\\\{\}  
        }
        \usepackage{xcolor} 
    number-sections: true
    colorlinks: true
    code-line-numbers: false
toc: true
toc-depth: 10
number-sections: true
number-depth: 100
date-format: full 
date-modified: now
code-fold: false
code-overflow: scroll
code-line-numbers: true
code-copy: true
---

# S1. Introduction

This document contain two main sections: (i) detailed protocol for conducting the experiment of fruit removal, and (ii) the simulation of data-generating process, explaining how biogeographical, regional, and local factors affect the probability of fruit removal across worldwide islands. Specifically, we provide a directed acyclic graph (DAG) that captures the hypothesized interdependencies among variables, including the rationale for each causal association. We use part of the DAG to simulate a synthetic data set, recreating the structure of our data and a simplified version of the generative model. Finally, we present models fitted to the simulated data, a crucial step for verifying that they are well-specified and can recover the 'true' parameters. 


# S2. Protocols for data collections

## Fruit removal experiments

In this project, we will use **artificial non-toxic plasticine red fruits** (Alves-Costa and Lopes 2001) to test the
effects of macro and microecological drivers on fruit removal at a global scale. We will focus on islands,
regarded as the most fragile ecosystems on Earth where 80% of the reported extinctions globally has happen
(Whittaker et al. 2017). It is urgent to assess the magnitude of frugivore loss worldwide to foresee the
consequences for island biodiversity maintenance and the ecosystem services provided by seed dispersal (Bello
et al. 2015, Egerer et al. 2018). \underline{Plasticine clays can be eaten by birds (and other animals including humans) with
no harm}.

![A contrast between artificial clay fruit models and natural animal-dispersed fruits](figures/comparison_fruits.png)


### Macroecological variables
- Island Size (ha)
- Island Isolation: measured as the total land area within a buffer zone around the island. Note that the land area of the island being analysed was not included in this calculation. As such, this variable measures the land mass of other islands or mainland nearby the main island. We estimated this variable using two buffer zone sizes: 500-km width (main analyses) and 1000-km width (supplementary analyses).
- Distance from the largest land mass: measured as the shortest Haversine (i.e., great circle) distance (km) between the island and the mainland. Note that some islands (e.g., New Guinea, New Zealand) have a distance of zero because they are considered as being mainland.
- Island Type (Continental, Volcanic or Limestone)
- Latitude
- Bioregion (Holt et al. 2013)

### Local Variables

- Altitude (m) where the experimental grids are deployed
- Human population: calculated as the mean population density of the island. We used the Population Density v4.11 global raster at a 30 arc-second horizontal resolution (available at <https://sedac.ciesin.columbia.edu/data/set/gpw-v4-population-density-rev11/data-download>). We calculated the average population density considering all the cells that overlapped the island. We extracted population density values using the extract function from the raster package.
- Natural vegetation cover of the island (%)
- Ranking of exotic vegetation in the experimental grid (1-3, 1 none, 2 medium (some sparce exotic species),
3 dominated by exotic plant species)
- Canopy cover (%) of the fruiting plants in the experiment (it was measured using https://percentagecover.com)
- Mean temperature of the days that the experiment was deployed (Celsius).

### Sampling locations

To maximize the power to detect effects of island biogeography (size, isolation, age), latitudinal and altitudinal gradient, we are aiming for wide spread of sites across latitudes, defaunation status, island sizes and isolation. Our primary criterion for site selection was “naturalness”. Therefore, we ask each researcher to establish plots in a range of disturbances (but not urban areas or gardens).

The site used to place the grid should be subject to a range of minimal disturbance to sites more disturbed (but not gardens or urban areas). Some sites are known to be dominated by invasive species, some are not, but we avoided installing the experiments on edges of large, paved roads. Each grid (0.5 ha) should was installed in different, representative habitats (one per habitat). 

We were not restricted to sites of a particular vegetation type, because we consider vegetation changes with latitude to be an ecologically important global pattern, which is likely to influence global patterns in frugivory, bird densities, and fruit removal. Thus, we aimed to establish sites in the most abundant natural vegetation type in each area, but also in invasive-dominated habitats. We aimed to capture variation in vegetation types that reflects the actual range of environmental conditions where animal-fruit interactions occur on each island.

To provide a standardized fruit, we modeled artificial fruits (10 mm diameter) from **non-toxic red plasticine clay** to resemble a typical bird-dispersed fruit (Alves-Costa and Lopes 2001). This type of fruit was chosen as it represents the most abundant group of fleshy fruit found throughout the world. Small marks (such as marks from fingernails) should be smoothed over. We used Plastilina (modelling clay) and sculpturing wire (see Figure S2) to install the fruits. We tested experimentally fruit fate by installing artificial fruits within 3-5 grids in which each grid encompasses an area of approximately 0.5 ha (100 x 50m). In each grid, we selected 12 separate understory bushes with ~1.5-2m height. Then for each bush, we installed 15 red plasticine fruits at about 1 m height. Each fruit should be placed between 5-30 cm from each other. Therefore, each grid will have 180 red plasticine fruits deployed evenly among 12 bushes (or a density of 3.6 fruits/100 $m^2$).

![How to deploy the red artificial fruits in the bushes and a detail of a artificial fruit attached to the
truck by a wire.](figures/bush_fruits.jpg)

### Setting the experiment step-by-step

:::{}

1.  Installing the experiment around the main fruiting season of the island location.
2.  Selecting a suitable location in the island to place 3 to 5 grids (100 x 50 m) depending on the
size of the island. Each grid was spaced at least 500 m from each other to cover different vegetation types.

![Experimental design and dimensions (100 x 50 m) of one of the grid and bushes disposition](figures/exp_desing.png)

3.  We selected 12 naturally growing 1.5-2 m tall bushes inside the grid, avoid installing artificial fruits in bushes with natural fruits.

4.  We installed 15 red plasticine fruits in 12 bushes, guaranteeing the fruits can be accessible to all kinds of birds, or arboreal lizards. Thus, the fruits were be placed in terminal branches mimicking a fruiting species. Each bush was spaced between 10-30 m in a grid system, so the density of fruits per grid was be 180 fruits/0.5 ha.

5.  We collect for each bush, latitude, and longitude with GPS (in UTM and using WGS84 Datum) and canopy cover (with the APP - https://percentagecover.com).

6.  We returned to the grid after 72 h and checked the marks of the frugivores (birds, mammals, lizards, arthropods, or unknown; Figure S4) on the artificial fruits. Fallen fruits were also checked and if we cannot find any mark, it was considerated as intact. We also recorded the number of missing fruits.

![Characteristic attack marks of birds (1-9), mammals (10-13), invertebrates (14-16)(Photos Rafael Souza).](figures/fruit_marks.png)

:::

## References

:::{}

- Alves-Costa, C. P., and A. V. Lopes. 2001. Using artificial fruits to evaluate fruit selection by birds in the field. Biotropica 33:713-717.

- Beckman, N. G., C. E. Aslan, H. S. Rogers, O. Kogan, J. L. Bronstein, J. M. Bullock, F. Hartig, J.
HilleRisLambers, Y. Zhou, and D. Zurell. 2020. Advancing an interdisciplinary framework to study seed dispersal ecology. AoB Plants 12:plz048.

- Bello, C., M. Galetti, M. A. Pizo, L. F. Magnago, M. F. Rocha, R. A. Lima, C. A. Peres, O. Ovaskainen, and P.
Jordano. 2015. Defaunation affects carbon storage in tropical forests. Sci Adv 1:e1501105.

- Cazetta, E., D. S. Ribeiro, C. R. Cassano, D. Faria, P. Dodonov, and J. E. Baumgarten. 2019. Forest amount, not
structure, influences fruit removal of two pioneer species in Atlantic forest remnants. Biotropica.

- Egerer, M. H., E. C. Fricke, and H. S. Rogers. 2018. Seed dispersal as an ecosystem service: frugivore loss leads
to decline of a socially valued plant, Capsicum frutescens. Ecological Applications 28:655-667.

- Ferger, S. W., H. I. Dulle, M. Schleuning, and K. Böhning‐Gaese. 2016. Frugivore diversity increases frugivory
rates along a large elevational gradient. Oikos 125:245-253.

- Fleming, T. H., and W. J. Kress. 2013. The ornaments of life: coevolution and conservation in the tropics.
University of Chicago Press.

- Galetti, M., C. P. Alves-Costa, and E. Cazetta. 2003. Effects of forest fragmentation, anthropogenic edges and
fruit colour on the consumption of ornithocoric fruits. Biological conservation 111:269-273.

- Hazell, R. J. 2020. Functional relationships between birds and fruits on an elevational gradient in Papua New
Guinea. University of Sussex.

- Holt, B. G., J.-P. Lessard, M. K. Borregaard, S. A. Fritz, M. B. Araújo, D. Dimitrov, P.-H. Fabre, C. H. Graham,
G. R. Graves, and K. A. Jønsson. 2013. An update of Wallace’s zoogeographic regions of the world.
science 339:74-78.

- Roslin, T., B. Hardwick, V. Novotny, W. K. Petry, N. R. Andrew, A. Asmus, I. C. Barrio, Y. Basset, A. L. Boesing,
and T. C. Bonebrake. 2017. Higher predation risk for insect prey at low latitudes and elevations. science
356:742-744.

- Wang, B. C., and T. B. Smith. 2002. Closing the seed dispersal loop. Trends in Ecology & Evolution 17:379-385.
Whittaker, R. J., J. M. Fernández-Palacios, T. J. Matthews, M. K. Borregaard, and K. A. Triantis. 2017. Island
biogeography: Taking the long view of nature’s laboratories. science 357.

:::

# S3. Data-generating process

![A directed acyclic graph (DAG) depicting the data-generating processes through which biogeographical, regional, and local factors affect fruit removal probability on islands worldwide](figures/DAG_islands.png)


The geological or biological – in the case of coralline formations – origin of the islands defines their type, which in turn encompasses the patterns of isolation, size, and altitude of the islands. Indeed, island traits likely shape the characteristics of their biological communities and the ways humans have impacted them. For instance, biodiversity patterns on islands can be influenced by proximity to the continental mainland or island size. These same traits may have determined historic human colonization processes and current impacts on native ecosystems. Thus, although some of those effects may not be linear due to the consequences of human technology—for instance, overcoming island isolation—we believe the causal structure in the previous Figure S1 remains plausible. Together, these factors may shape the probability of fruit removal directly or indirectly through other predictors.


# S4. Simulation of synthetic data 

We focused on one part of the previous data-generative processes:

![Simplified version of the DAG used to simulate the synthetic data set](figures/DAG_gen_mod.png)

This simplification does not compromise our purpose of testing whether the model is well-specified, since it preserves the main structure of the data and reproduces the hierarchical interdependencies among biogeographical, regional, and local factors.

## Loading packages 

`R` packages for data manipulation and model fitting, and custom functions (`functions_mod_diagnostics.r`) for assessing the quality of the models' fit.

```{r, warning=FALSE, message=FALSE, results='hide'}

set.seed(23061993)

sapply(c('cmdstanr', 'magrittr', 'dplyr',  
         'tidyr', 'tibble', 'forcats', 'geosphere', 
         'MASS', 'rethinking'), library, character.only = T)

source('functions_mod_diagnostics.r')
```

## Structure of the data  

We ensured that our generative simulation approximated the collected data in terms of structure, using the same number of islands, grids, and plants. The simulation also considered the distribution of island types across countries and used the distance between sampling localities to simulate spatial correlation.

```{r}
all_data <- readRDS('data_structure_simulation.rds')

sim_data <- all_data$data_structure
codes <- all_data$labels
dist_matrix <- all_data$dist_mat
```

## Parameters
We included *plant ID*, *grid ID*, and *country ID* as hierarchical random factors, and $\eta$ and $\rho$ parameters for the Gaussian process quadratic kernel, which simulates spatial correlation across islands.
**
**Random factors:**

```{r}
# random factors 
plants <- rnorm(nrow(sim_data), 0, 0.01) # pars plant
grid <- rnorm(max(sim_data$grid), 0, 0.015) # pars grid
country <- rnorm(max(sim_data$country2), 0, 1) # pars countries

```


**Spatial covariation among islands:** Here we used a quadratic kernel ($K = \eta \times e^{-0.5 \cdot (\frac{D_{ij}}{\rho})^2}$) for constructing the covariance matrix ($K$).

```{r}
# mu par island (without spatial correlation)
mu_island <- rnorm(nrow(dist_matrix), 0, 2) 
rho <- 0.25 # Rate of covariance decline between islands
eta <- 2 # Maximum covariance between consecutive islands 
delta <- 0.1 # No variation within islands

quadratic_kernel <- # kernel for constructing covariance matrix
  function(m, eta, rho, delta) {
    
    N <- ncol(m)
    mat <- matrix(ncol = N, nrow = N)
    
    for (i in 1:(N-1)) {
      for (j in (i+1):N) {
        mat[i, j] <- eta * exp(-0.5 * (m[i, j]/rho)^2)
        mat[j, i] <- mat[i, j]
      }
    }
    
    diag(mat) <- eta + delta
    mat
  }

# covariance matrix
cov_mat <- quadratic_kernel(dist_matrix, eta, rho, delta) 

res_cor_res <- # correlated residuals among islands
  mvrnorm(nrow(dist_matrix), 
        mu = rep(0, nrow(dist_matrix)), 
        Sigma = cov_mat)

islands <- 
  res_cor_res + 
  matrix(rep(mu_island, length(mu_island)), 
         nrow = length(mu_island), byrow = T)
# pars 
islands_pars <- islands[1, ] # correlated islands

```

**Fixed factors**
```{r}
type_island <- c(-1.5, 1.75, 0.25) # par type of island
```


**Island altitude variation by island type:**
```{r}
sim_alt <- 
  lapply(1, FUN = 
           function(x) {
             
             d <- unique(sim_data[, c("island", "island_type")])
             
             par_IT <- 
               sapply(1:43, FUN = 
                        function(x) {
                          i <- d$island_type[x]
                          # effect of island type on altitude
                          mu <- c(-0.5, 1.25, 0.8)[i] 
                          rnorm(1, mu, 0.5)
                        })
             
             d$par <- par_IT
             
             island_alt <- 
               lapply(1:43, FUN = 
                        function(j) {
                          island <- d$island[j]
                          island_type <- d$island_type[j]
                          par <- d$par[j]
                          
                          indx <- 
                            which(sim_data$island == island &
                                    sim_data$island_type == island_type)
                          
                          tibble(index = indx, 
                                 island_alt = par, 
                                 island = island, 
                                 island_type = island_type)
                          
                        })
             do.call('rbind', island_alt) 
           })[[1]]

sim_data$altitude <- NA
sim_data$altitude[sim_alt$index] <- sim_alt$island_alt

```


**Effect of island type on isolation, and of isolation on native vegetation cover:**

```{r}
isolation_vegetation <-
  lapply(1, FUN = 
           function(x) {
             
             d <- unique(sim_data[, c("island", "island_type")])
             
             par_iso <- 
               sapply(1:43, FUN = 
                        function(x) {
                          i <- d$island_type[x]
                          # effect of island type
                          # on isolation
                          mu <- c(-0.8, 0.25, 1.1)[i] 
                          rnorm(1, mu, 0.5)
                        })
             
             d$par <- par_iso
             # isolation --> native vegetation
             d$native_vegetation <- 
               rnorm(nrow(d), d$par * 0.5, 0.5)
             
             island_isolation <- 
               lapply(1:43, FUN = 
                        function(j) {
                          island <- d$island[j]
                          island_type <- d$island_type[j]
                          isolation <- d$par[j]
                          vegetation <- d$native_vegetation[j]
                          
                          indx <- 
                            which(sim_data$island == island &
                                    sim_data$island_type == island_type)
                          
                          tibble(index = indx, 
                                 isolation = isolation, 
                                 native_vegetation = vegetation,
                                 island = island, 
                                 island_type = island_type)
                          
                        })
             do.call('rbind', island_isolation) 
           })[[1]]

sim_data$island_isolation <- NA
sim_data$island_isolation[isolation_vegetation$index] <- 
  isolation_vegetation$isolation

sim_data$native_vegetation <- NA
sim_data$native_vegetation[isolation_vegetation$index] <- 
  isolation_vegetation$native_vegetation

```



**Effect of continuous factors on frugivory**

```{r}
beta_alt <- -1.8 # slope altitude
# Effect of native vegetation on bush cover
bush_cover <- rnorm(nrow(sim_data), 
                    sim_data$native_vegetation * 0.25, 0.5)
beta_nativeV <- 1.8 # effect native vegetation
beta_isolation <- 0.01 # effect island isolation
beta_bush <- 0.8 # effect of bush cover
```

## Simulated fruit consumption

Fruit consumption data were generated using a binomial probability distribution.

```{r}
sim_data$bush_cover <- bush_cover

fruit_removal <- 
  sapply(1:nrow(sim_data), FUN = 
         function(x) {
           p <- sim_data$plant_ID[x]
           g <- sim_data$grid[x]
           i <- sim_data$island[x]
           c <- sim_data$country2[x]
           TI <- sim_data$island_type[x]
           alt <- sim_data$altitude[x]
           iso <- sim_data$island_isolation[x]
           NV <- sim_data$native_vegetation[x]
           BC <- sim_data$bush_cover[x]
           rbinom(1, 15, # available fruit per bush 
                  inv_logit(alt * beta_alt + 
                            iso * beta_isolation +
                            NV * beta_nativeV +
                            BC * beta_bush +
                            plants[p] + 
                            grid[g] + 
                            islands_pars[i] +
                            country[c] +
                            type_island[TI]))
         }) 

sim_data$fruit_removal <- fruit_removal

```

Finally, all the data are stored as a `list` object.

```{r}
dat <- 
  list(N = nrow(sim_data), 
       N_islands = max(sim_data$island),
       N_grid = max(sim_data$grid),
       N_plant = max(sim_data$plant_ID), 
       N_country = max(sim_data$country2),
       N_type_island = max(sim_data$island_type),
       altitude = sim_data$altitude,
       island_isolation = sim_data$island_isolation, 
       native_cover = sim_data$native_vegetation, 
       bush_cover = sim_data$bush_cover,
       fruit_removal = sim_data$fruit_removal,
       type_island = sim_data$island_type,
       country_ID = sim_data$country2,
       islands_ID = sim_data$island,
       grid_ID = sim_data$grid, 
       plant_ID = sim_data$plant_ID,
       dist_islands = dist_matrix)
```


```{r, fig.cap='Simulated fruit removal'}
par(mar = c(4, 4, 1, 1))
plot(density(sim_data$fruit_removal), main = '', 
     xlab = 'Number of fruits consumed in a single bush')

```

# S5. Models

All models share the same structure for random effects and account for correlation among islands, but differ in the adjustment set of predictors required to estimate the correct causal effect. We therefore present the general mathematical notation here; the specific adjustment sets for each model are provided in subsequent sections.

Prior probabilities were defined to encompass plausible values of the response variable on the logit scale. Dispersion parameters were parameterized to explore positive values, while prior probabilities for the slope parameters of the causal effect and adjustment set variables were defined to allow for either positive or negative effects.

\pagebreak 

**Main model**

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \text{causal effect} + \text{adjustment set} + \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \text{causal effect} \sim \mathcal{N}(0, 1) \\
& \text{adjustment set} \sim \mathcal{N}(0, 1) \\
& \\
& K_{ij} = \eta \times exp(-\rho \cdot D_{ij}^2) \\
& LK_{ij} = L_K \times L_K^T \\
& \tau = LK_{ij} \times Z_{\tau ~ island~id} \\
& \eta \sim exponential(4) \\
& \rho \sim exponential(1) \\
& Z_{\tau ~ island~id} \sim \mathcal{N}(0, 1) \\
&\\
& \mu_{\theta} \sim \mathcal{N}(0, 0.5) \\
& Z_\theta \sim \mathcal{N}(0, 1) \\
& \sigma_{\theta} \sim exponential(1) \\
& \theta = \mu_\theta + Z_\theta \times \sigma_\theta \\
\\
& \mu_{\phi} \sim \mathcal{N}(0, 0.5) \\
& Z_\phi \sim \mathcal{N}(0, 1) \\
& \sigma_{\phi} \sim exponential(1) \\
& \phi = \mu_\phi + Z_\phi \times \sigma_\phi \\
\\
& \mu_{\psi} \sim \mathcal{N}(0, 0.5) \\
& Z_\psi \sim \mathcal{N}(0, 1) \\
& \sigma_{\psi} \sim exponential(1) \\
& \psi = \mu_\psi + Z_\psi \times \sigma_\psi \\
\end{aligned}
$$

# S6. Effect of altitude


![The red arrow indicates the estimand (i.e., the effect of the green factor on the red response variable), while orange factors represent the adjustment set required for correct causal effect estimation.](figures/DAG_altitude.png)

Correctly estimating the effect $altitude \rightarrow fruit~removal$ requires conditioning on *island type*, since it is a common cause of both altitude and fruit removal; omitting it would bias the estimate.


## Mathematical version

Random effects and correlated islands remain as showed in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{altitude~i} + \gamma_{type~of~island} + \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
& \gamma \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      real beta_alt;
      // real beta_iso;
      // beta beta_NV;
      // beta beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      beta_alt ~ normal(0, 1);
      // beta_iso ~ normal(0, 1);
      // beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(4);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen1.rds')

```


## Model diagnostics 


```{r, fig.cap='Bulk and tail effective sample size (ESS) of estimated parameters (left). Posterior predictive distributions showing model fit quality (right).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      'beta_alt',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', 'beta_alt', 'TI', 'country', 'island', 
         'grid', 'plant'), FUN = 
         function(x) {
           posterior_pars[, grep(x, colnames(posterior_pars))]
         })

names(posterior_pars) <- c('alpha', 'beta_alt', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery

The function `compare_posterior()` is used to compare estimated vs true parameter of the model.

```{r}
compare_posterior <- 
  function(post = posterior_pars$island, 
           real = islands_pars, 
           xlab = 'Islands', 
           ylab = 'Posterior mean', 
           main = 'Island parameters') {
    post <- 
      do.call('rbind', 
              lapply(post, FUN = 
                       function(x) {
                         tibble(li = quantile(x, 0), 
                                ls = quantile(x, 1), 
                                mu = mean(x))
                       }))
    post$x <- 1:nrow(post)
    post$real <- real
    
    plot(NULL, xlim = c(0, nrow(post)), ylim = c(-10, 10), 
         ylab = ylab, xlab = xlab, 
         main = main)
    post %$% 
      segments(y0 = li, y1 = ls, x0 = x)
    post %$%
      points(x = x, y = mu)
    post %$%
      points(x = x, y = real, pch = 16, col = 'red')
  }
```

**Random effects:**

```{r, fig.cap='Country parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```


**Main effect**

```{r, fig.cap='Effect of altitude on fruit removal. The density line indicates the posterior distribution, while the vertical red line shows the "true" parameter value.'}
plot(density(posterior_pars$beta_alt$beta_alt), 
     main = '', xlab = expression(beta['altitude']), 
     xlim = c(-4, 4))
abline(v = beta_alt, col = 'red', lwd = 2)
```

# S7. Effect type of island

![The red arrow indicates the estimand (i.e., the effect of the green factor on the red response variable), while orange factors represent the adjustment set required for correct causal effect estimation.](figures/DAG_type_island.png)


Correctly estimating the effect $island~type \rightarrow fruit~removal$ requires excluding any mediating pathways that could block the estimand's effect. Therefore, no additional factors should be included.

## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \gamma_{type~of~island} + \theta_{plant~id} +\\
& ~~~~~~~~~~~~~~~~~~ \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \gamma \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      //real beta_alt;
      // real beta_iso;
      // beta beta_NV;
      // beta beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      // beta_iso ~ normal(0, 1);
      // beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(4);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               // beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 2e3,
    thin = 5,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen2.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      #'beta_iso',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha',  'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effect of type of island on fruit removal. The density line indicates the posterior distribution, while the vertical red line shows the "true" parameter value.'}
compare_posterior(posterior_pars$TI,
                  type_island,
                  xlab = 'Type of island',
                  ylab = 'Posterior mean',
                  main = 'Type of island parameters')
```


# S8. Effect of island isolation

![The red arrow indicates the estimand (i.e., the effect of the green factor on the red response variable), while orange factors represent the adjustment set required for correct causal effect estimation.](figures/DAG_isolation.png)

Correctly estimating the effect $isolation \rightarrow fruit~removal$ requires conditioning on island type, since it is a common cause of both isolation and fruit removal; omitting it would bias the estimate.


## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{isolation~i} + \gamma_{type~of~island} + \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
& \gamma \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      // real beta_alt;
      real beta_iso;
      // beta beta_NV;
      // beta beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      beta_iso ~ normal(0, 1);
      // beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(3);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial_logit(15, 
                               alpha +
                               // beta_alt * altitude +
                               beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]);
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen3.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      'beta_iso',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', 'beta_iso', 'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', 'beta_iso', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameters. Red dots indicate the true values, whereas error bars and hollow dots represent the means and 95 percent credible intervals (CIs) of the posterior distributions.'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effect of island isolation on fruit removal. The density line indicates the posterior distribution, while the vertical red line shows the "true" parameter value.'}

beta_tot_isolation <- 
  beta_nativeV * (0.5) + 
  beta_bush * (0.25 * 0.5) + 
  beta_isolation # total effect of isolation

plot(density(posterior_pars$beta_iso$beta_iso), 
     main = '', xlab = expression(beta['isolation']), 
     xlim = c(-4, 4))
abline(v = beta_tot_isolation, col = 'red', lwd = 2)

```


# S9. Effect of bush cover

![The red arrow indicates the estimand (i.e., the effect of the green factor on the red response variable), while orange factors represent the adjustment set required for correct causal effect estimation.](figures/DAG_bush.png)


Correctly estimating the effect $bush~cover \rightarrow fruit~removal$ requires conditioning on native vegetation cover, since it is a common cause of both bush cover and fruit removal; omitting it would bias the estimate.


## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{bush~cover~i} + \beta_{native~cover~i} + \theta_{plant~id} + \\
& ~~~~~~~~~~~~~~~~~~ \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      // real beta_alt;
      // real beta_iso;
      real beta_NV;
      real beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      // beta_iso ~ normal(0, 1);
      beta_NV ~ normal(0, 1);
      beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(3);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               // beta_alt * altitude +
                               //beta_iso * island_isolation +
                               beta_NV * native_cover +
                               beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               //beta_iso * island_isolation +
                               beta_NV * native_cover +
                               beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen4.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      #'beta_iso',
                      'beta_NV',
                      'beta_bush',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', #'beta_iso', 
           'beta_NV', 'beta_bush', 'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', #'beta_iso', 
                           'beta_NV', 'beta_bush', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution.'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution.'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effect of bush cover on fruit removal. Density line indicate the posterior distribution, whereas the vertical red line the "true" value of the parameter'}
plot(density(posterior_pars$beta_bush$beta_bush), 
     main = '', xlab = expression(beta['bush cover']), 
     xlim = c(-2, 2))
abline(v = beta_bush, col = 'red', lwd = 2)
```


# S10. Effect of native vegetation

![The red arrow indicates the estimand (i.e., the effect of the green factor on the red response variable), while orange factors represent the adjustment set required for correct causal effect estimation.](figures/DAG_nativeV.png)


Estimating correctly the effect $native~vegetation \rightarrow fruit~removal$ implies conditioning on island isolation since it is a common causes of our predictor and response variable. 

## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{native~cover~i} + \beta_{isolation~i} +  \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      // real beta_alt;
      real beta_iso;
      real beta_NV;
      // real beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      beta_iso ~ normal(0, 1);
      beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(4);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               // beta_alt * altitude +
                               beta_iso * island_isolation +
                               beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               beta_iso * island_isolation +
                               beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen5.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      'beta_iso',
                      'beta_NV',
                      #'beta_bush',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', 'beta_iso', 
           'beta_NV', #'beta_bush', 
           'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', 'beta_iso', 
                           'beta_NV', 
                           #'beta_bush', 
                           'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameters. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 95 percent CI of the posterior distribution'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effects of island isolation (direct) and native cover (total) on fruit removal. Density line indicate the posterior distribution, whereas the vertical red line the "true" value of the parameter'}

par(mfrow = c(1, 2))
plot(density(posterior_pars$beta_iso$beta_iso), main = '', 
     xlab = expression(beta['island isolation']), 
     xlim = c(-4, 4))
abline(v = beta_isolation, lwd = 2, col = 'red')

plot(density(posterior_pars$beta_NV$beta_NV), main = '', 
     xlab = expression(beta['Native vegetation']), xlim = c(-4, 4))
abline(v = beta_nativeV, lwd = 2, col = 'red')
par(mfrow = c(1, 1))

```


# S11 Conclusion 

All models (see Sections 6.6, 7.6, 8.6, 9.6, and 10.6) recovered the true parameters of the generative simulation, indicating that they were well-specified and adequate for detecting the target effects. Therefore, our models are ready to be applied to the real data.








