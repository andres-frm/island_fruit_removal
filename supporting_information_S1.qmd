---
title: "Measuring the macroecological and local effects on plant-animal interaction using artificial fruits"
subtitle: 'Authors: '
author: "Supporting Information S1. Journal XXX"
format:
  pdf: 
    include-in-header:
      text: |
        \renewcommand{\thesubsection}{S\arabic{section}.\arabic{subsection}}
        \renewcommand{\thefigure}{S\arabic{figure}}
        \renewcommand{\thetable}{S\arabic{table}}
        \usepackage{fvextra}
        \DefineVerbatimEnvironment{Highlighting}{Verbatim}{
          fontsize=\footnotesize,
          baselinestretch=0.8,
          commandchars=\\\{\}  
        }
        \usepackage{xcolor} 
    toc: true
    toc-depth: 10
    number-sections: true
    colorlinks: true
    code-line-numbers: false
    code-font-size: small
number-sections: true
number-depth: 100
date-format: full 
date-modified: now
code-fold: false
code-overflow: scroll
code-line-numbers: true
code-copy: true
---

# S1. Introduction

This document contain two main sections: (i) detailed protocol for conducting the experiment of fruit removal, and (ii) the simulation of data-generating process, explaining how biogeographical, regional, and local factors affect the probability of fruit removal across worldwide islands. Specifically, we provide a directed acyclic graph (DAG) that captures the hypothesized interdependencies among variables, including the rationale for each causal association. We use part of the DAG to simulate a synthetic data set, recreating the structure of our data and a simplified version of the generative model. Finally, we present models fitted to the simulated data, a crucial step for verifying that it is well-specified and can recover the 'true' parameters. 


# S2. Protocols for data collections

## Fruit removal experiments

In this project, we will use **artificial non-toxic plasticine red fruits** (Alves-Costa and Lopes 2001) to test the
effects of macro and microecological drivers on fruit removal at a global scale. We will focus on islands,
regarded as the most fragile ecosystems on Earth where 80% of the reported extinctions globally has happen
(Whittaker et al. 2017). It is urgent to assess the magnitude of frugivore loss worldwide to foresee the
consequences for island biodiversity maintenance and the ecosystem services provided by seed dispersal (Bello
et al. 2015, Egerer et al. 2018). \underline{Plasticine clays can be eaten by birds (and other animals including humans) with
no harm}.

![A contrast between artificial clay fruit models and natural animal-dispersed fruits](figures/comparison_fruits.png)


### Macroecological variables
- Island Size (ha)
- Island Isolation: measured as the total land area within a buffer zone around the island. Note that the land area of the island being analysed was not included in this calculation. As such, this variable measures the land mass of other islands or mainland nearby the main island. We estimated this variable using two buffer zone sizes: 500-km width (main analyses) and 1000-km width (supplementary analyses).
- Distance from the largest land mass: measured as the shortest Haversine (i.e., great circle) distance (km) between the island and the mainland. Note that some islands (e.g., New Guinea, New Zealand) have a distance of zero because they are considered as being mainland.
- Island Type (Continental, Volcanic or Limestone)
- Latitude
- Bioregion (Holt et al. 2013)

### Local Variables

- Altitude (m) where the experimental grids are deployed
- Human population: calculated as the mean population density of the island. We used the Population Density v4.11 global raster at a 30 arc-second horizontal resolution (available at <https://sedac.ciesin.columbia.edu/data/set/gpw-v4-population-density-rev11/data-download>). We calculated the average population density considering all the cells that overlapped the island. We extracted population density values using the extract function from the raster package.
- Natural vegetation cover of the island (%)
- Ranking of exotic vegetation in the experimental grid (1-3, 1 none, 2 medium (some sparce exotic species),
3 dominated by exotic plant species)
- Canopy cover (%) of the fruiting plants in the experiment (it was measured using https://percentagecover.com)
- Mean temperature of the days that the experiment was deployed (Celsius).

### Sampling locations

To maximize the power to detect effects of island biogeography (size, isolation, age), latitudinal and altitudinal gradient, we are aiming for wide spread of sites across latitudes, defaunation status, island sizes and isolation. Our primary criterion for site selection was “naturalness”. Therefore, we ask each researcher to establish plots in a range of disturbances (but not urban areas or gardens).

The site used to place the grid should be subject to a range of minimal disturbance to sites more disturbed (but not gardens or urban areas). Some sites are known to be dominated by invasive species, some are not, but we avoided installing the experiments on edges of large, paved roads. Each grid (0.5 ha) should was installed in different, representative habitats (one per habitat). 

We were not restricted to sites of a particular vegetation type, because we consider vegetation changes with latitude to be an ecologically important global pattern, which is likely to influence global patterns in frugivory, bird densities, and fruit removal. Thus, we aimed to establish sites in the most abundant natural vegetation type in each area, but also in invasive-dominated habitats. We aimed to capture variation in vegetation types that reflects the actual range of environmental conditions where animal-fruit interactions occur on each island.

To provide a standardized fruit, we modeled artificial fruits (10 mm diameter) from **non-toxic red plasticine clay** to resemble a typical bird-dispersed fruit (Alves-Costa and Lopes 2001). This type of fruit was chosen as it represents the most abundant group of fleshy fruit found throughout the world. Small marks (such as marks from fingernails) should be smoothed over. We used Plastilina (modelling clay) and sculpturing wire (see Figure S2) to install the fruits. We tested experimentally fruit fate by installing artificial fruits within 3-5 grids in which each grid encompasses an area of approximately 0.5 ha (100 x 50m). In each grid, we selected 12 separate understory bushes with ~1.5-2m height. Then for each bush, we installed 15 red plasticine fruits at about 1 m height. Each fruit should be placed between 5-30 cm from each other. Therefore, each grid will have 180 red plasticine fruits deployed evenly among 12 bushes (or a density of 3.6 fruits/100 $m^2$).

![How to deploy the red artificial fruits in the bushes and a detail of a artificial fruit attached to the
truck by a wire.](figures/bush_fruits.jpg)

### Setting the experiment step-by-step

:::{}

1.  Installing the experiment around the main fruiting season of the island location.
2.  Selecting a suitable location in the island to place 3 to 5 grids (100 x 50 m) depending on the
size of the island. Each grid was spaced at least 500 m from each other to cover different vegetation types.

![Experimental design and dimensions (100 x 50 m) of one of the grid and bushes disposition](figures/exp_desing.png)

3.  We selected 12 naturally growing 1.5-2 m tall bushes inside the grid, avoid installing artificial fruits in bushes with natural fruits.

4.  We installed 15 red plasticine fruits in 12 bushes, guaranteeing the fruits can be accessible to all kinds of birds, or arboreal lizards. Thus, the fruits were be placed in terminal branches mimicking a fruiting species. Each bush was spaced between 10-30 m in a grid system, so the density of fruits per grid was be 180 fruits/0.5 ha.

5.  We collect for each bush, latitude, and longitude with GPS (in UTM and using WGS84 Datum) and canopy cover (with the APP - https://percentagecover.com).

6.  We returned to the grid after 72 h and checked the marks of the frugivores (birds, mammals, lizards, arthropods, or unknown; Figure S4) on the artificial fruits. Fallen fruits were also checked and if we cannot find any mark, it was considerated as intact. We also recorded the number of missing fruits.

![Characteristic attack marks of birds (1-9), mammals (10-13), invertebrates (14-16)(Photos Rafael Souza).](figures/fruit_marks.png)

:::

# S3. Data-generating process


![A directed acyclic graph denoting the data-generating processes explaining how biogeographical, regional, and local factors affect the probability of fruit removal in worldwide islands.](figures/DAG_islands.png)


The geological or biological – in the case of coraline formations – origin of the islands defines their type, which in turn encompasses the patterns of isolation, size, and altitude of the islands. Indeed, island traits likely shape the characteristics of their biological communities and the ways humans have impacted them. For instance, biodiversity patterns on islands can be influenced by proximity to the continental mainland or island size. The same traits can have determined historic human colonization processes and current impacts on native ecosystems. Thus, although some of those effects may not be linear due to the consequences of human technology —for instance, overcoming island isolation — we believe the causal structure in the previous Figure S1 remains plausible. Together, these factors may shape the probability of fruit removal directly or indirectly through other predictors.


# S4. Simulation of synthetic data 

We focused on one part of the previous data-generative processes:

![Simplified version of the DAG used to simulate the synthetic data set](figures/DAG_gen_mod.png)

This simplification does not compromise our purpose of testing whether the model is well-specified, since it preserves the main structure of the data and reproduces the hierarchical interdependencies among biogeographical, regional, and local factors.

## Loading packages 

`R` packages for data manipulation and models' fitting, and custom functions (`functions_mod_diagnostics.r`) for assessing the quality of the models' fit.

```{r, warning=FALSE, message=FALSE, results='hide'}

set.seed(23061993)

sapply(c('cmdstanr', 'magrittr', 'dplyr',  
         'tidyr', 'tibble', 'forcats', 'geosphere', 
         'MASS', 'rethinking'), library, character.only = T)

source('functions_mod_diagnostics.r')
```

## Structure of the data  

We ensured that our generative simulation approximated the collected data in terms of structure, using the same number of islands, grids, and plants. The simulation also considered the distribution of island types across countries and used the distance between sampling localities to simulate spatial correlation.

```{r}
all_data <- readRDS('data_structure_simulation.rds')

sim_data <- all_data$data_structure
codes <- all_data$labels
dist_matrix <- all_data$dist_mat
```

## Parameters 

We included *plant id*, *grid id*, and *country id* as hierarchical random factors; $\eta$ and $\rho$ parameters for the quadratic kernel of Gaussian process, which simulate spatial correlation across islands.

**Random factors:**
```{r}
# random factors 
plants <- rnorm(nrow(sim_data), 0, 0.01) # pars plant
grid <- rnorm(max(sim_data$grid), 0, 0.015) # pars grid
country <- rnorm(max(sim_data$country2), 0, 1) # pars countries

```


**Spatial covariation among islands:** Here we used a quadratic kernel ($K = \eta \times e^{-0.5 \cdot (\frac{D_{ij}}{\rho})^2}$) for constructing the covariance matrix ($K$).

```{r}
# mu par island (without spatial correlation)
mu_island <- rnorm(nrow(dist_matrix), 0, 2) 
rho <- 0.25 # Rate of covariance decline between islands
eta <- 2 # Maximum covariance between consecutive islands 
delta <- 0.1 # No variation within islands

quadratic_kernel <- # kernel for constructing covariance matrix
  function(m, eta, rho, delta) {
    
    N <- ncol(m)
    mat <- matrix(ncol = N, nrow = N)
    
    for (i in 1:(N-1)) {
      for (j in (i+1):N) {
        mat[i, j] <- eta * exp(-0.5 * (m[i, j]/rho)^2)
        mat[j, i] <- mat[i, j]
      }
    }
    
    diag(mat) <- eta + delta
    mat
  }

# covariance matrix
cov_mat <- quadratic_kernel(dist_matrix, eta, rho, delta) 

res_cor_res <- # correlated residuals among islands
  mvrnorm(nrow(dist_matrix), 
        mu = rep(0, nrow(dist_matrix)), 
        Sigma = cov_mat)

islands <- 
  res_cor_res + 
  matrix(rep(mu_island, length(mu_island)), 
         nrow = length(mu_island), byrow = T)
# pars 
islands_pars <- islands[1, ] # correlated islands

```

**Fixed factors**
```{r}
type_island <- c(-1.5, 1.75, 0.25) # par type of island
```


**Islands of variant altitude depending on their type:**
```{r}
sim_alt <- 
  lapply(1, FUN = 
           function(x) {
             
             d <- unique(sim_data[, c("island", "island_type")])
             
             par_IT <- 
               sapply(1:43, FUN = 
                        function(x) {
                          i <- d$island_type[x]
                          # effect of island type on altitude
                          mu <- c(-0.5, 1.25, 0.8)[i] 
                          rnorm(1, mu, 0.5)
                        })
             
             d$par <- par_IT
             
             island_alt <- 
               lapply(1:43, FUN = 
                        function(j) {
                          island <- d$island[j]
                          island_type <- d$island_type[j]
                          par <- d$par[j]
                          
                          indx <- 
                            which(sim_data$island == island &
                                    sim_data$island_type == island_type)
                          
                          tibble(index = indx, 
                                 island_alt = par, 
                                 island = island, 
                                 island_type = island_type)
                          
                        })
             do.call('rbind', island_alt) 
           })[[1]]

sim_data$altitude <- NA
sim_data$altitude[sim_alt$index] <- sim_alt$island_alt

```


**Effect of island type on isolation, and effect of isolation on the cover of native vegetation:**

```{r}
isolation_vegetation <-
  lapply(1, FUN = 
           function(x) {
             
             d <- unique(sim_data[, c("island", "island_type")])
             
             par_iso <- 
               sapply(1:43, FUN = 
                        function(x) {
                          i <- d$island_type[x]
                          # effect of island type
                          # on isolation
                          mu <- c(-0.8, 0.25, 1.1)[i] 
                          rnorm(1, mu, 0.5)
                        })
             
             d$par <- par_iso
             # isolation --> native vegetation
             d$native_vegetation <- 
               rnorm(nrow(d), d$par * 0.5, 0.5)
             
             island_isolation <- 
               lapply(1:43, FUN = 
                        function(j) {
                          island <- d$island[j]
                          island_type <- d$island_type[j]
                          isolation <- d$par[j]
                          vegetation <- d$native_vegetation[j]
                          
                          indx <- 
                            which(sim_data$island == island &
                                    sim_data$island_type == island_type)
                          
                          tibble(index = indx, 
                                 isolation = isolation, 
                                 native_vegetation = vegetation,
                                 island = island, 
                                 island_type = island_type)
                          
                        })
             do.call('rbind', island_isolation) 
           })[[1]]

sim_data$island_isolation <- NA
sim_data$island_isolation[isolation_vegetation$index] <- 
  isolation_vegetation$isolation

sim_data$native_vegetation <- NA
sim_data$native_vegetation[isolation_vegetation$index] <- 
  isolation_vegetation$native_vegetation

```



**Effect of continuous factors on frugivory**

```{r}
beta_alt <- -1.8 # slope altitude
# Effect of native vegetation on bush cover
bush_cover <- rnorm(nrow(sim_data), 
                    sim_data$native_vegetation * 0.25, 0.5)
beta_nativeV <- 1.8 # effect native vegetation
beta_isolation <- 0.01 # effect island isolation
beta_bush <- 0.8 # effect of bush cover
```

## Simulated fruit consumption

We used a binomial probability distribution to generate fruit consumption.

```{r}
sim_data$bush_cover <- bush_cover

fruit_removal <- 
  sapply(1:nrow(sim_data), FUN = 
         function(x) {
           p <- sim_data$plant_ID[x]
           g <- sim_data$grid[x]
           i <- sim_data$island[x]
           c <- sim_data$country2[x]
           TI <- sim_data$island_type[x]
           alt <- sim_data$altitude[x]
           iso <- sim_data$island_isolation[x]
           NV <- sim_data$native_vegetation[x]
           BC <- sim_data$bush_cover[x]
           rbinom(1, 15, # available fruit per bush 
                  inv_logit(alt * beta_alt + 
                            iso * beta_isolation +
                            NV * beta_nativeV +
                            BC * beta_bush +
                            plants[p] + 
                            grid[g] + 
                            islands_pars[i] +
                            country[c] +
                            type_island[TI]))
         }) 

sim_data$fruit_removal <- fruit_removal

```

Finally, all the data is stored as a `list` object.

```{r}
dat <- 
  list(N = nrow(sim_data), 
       N_islands = max(sim_data$island),
       N_grid = max(sim_data$grid),
       N_plant = max(sim_data$plant_ID), 
       N_country = max(sim_data$country2),
       N_type_island = max(sim_data$island_type),
       altitude = sim_data$altitude,
       island_isolation = sim_data$island_isolation, 
       native_cover = sim_data$native_vegetation, 
       bush_cover = sim_data$bush_cover,
       fruit_removal = sim_data$fruit_removal,
       type_island = sim_data$island_type,
       country_ID = sim_data$country2,
       islands_ID = sim_data$island,
       grid_ID = sim_data$grid, 
       plant_ID = sim_data$plant_ID,
       dist_islands = dist_matrix)
```


```{r, fig.cap='Simulated fruit removal'}
par(mar = c(4, 4, 1, 1))
plot(density(sim_data$fruit_removal), main = '', 
     xlab = 'Number of fruits consumed in a single bush')

```

# S5. Models

All models preserve the same structure with respect to random effects and correlated islands, but they differ in the adjustment set of predictors that should be included to detect the correct causal effect. Thus, we present the overall mathematical notation for all models here, whereas the specific adjustment sets for the models will be provided below. 

Prior probabilities were defined to cover plausible values of the response variable on the $logit$ scale. Dispersion parameters were parametrized to explore positive values, whereas prior probabilities of slope parameters of *causal effect* and *adjustment set* were defined to explore either positive or negative effects.

\pagebreak 

**Main model**

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \text{causal effect} + \text{adjustment set} + \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \text{causal effect} \sim \mathcal{N}(0, 1) \\
& \text{adjustment set} \sim \mathcal{N}(0, 1) \\
& \\
& K_{ij} = \eta \times exp(-\rho \cdot D_{ij}^2) \\
& LK_{ij} = L_K \times L_K^T \\
& \tau = LK_{ij} \times Z_{\tau ~ island~id} \\
& \eta \sim exponential(4) \\
& \rho \sim exponential(1) \\
& Z_{\tau ~ island~id} \sim \mathcal{N}(0, 1) \\
&\\
& \mu_{\theta} \sim \mathcal{N}(0, 0.5) \\
& Z_\theta \sim \mathcal{N}(0, 1) \\
& \sigma_{\theta} \sim exponential(1) \\
& \theta = \mu_\theta + Z_\theta \times \sigma_\theta \\
\\
& \mu_{\phi} \sim \mathcal{N}(0, 0.5) \\
& Z_\phi \sim \mathcal{N}(0, 1) \\
& \sigma_{\phi} \sim exponential(1) \\
& \phi = \mu_\phi + Z_\phi \times \sigma_\phi \\
\\
& \mu_{\psi} \sim \mathcal{N}(0, 0.5) \\
& Z_\psi \sim \mathcal{N}(0, 1) \\
& \sigma_{\psi} \sim exponential(1) \\
& \psi = \mu_\psi + Z_\psi \times \sigma_\psi \\
\end{aligned}
$$

# S6. Effect of altitude

![The red arrow indicates our estimand (i.e., the effect of the factor in green on the response in red), and orange factors indicate the adjustment set to correctly estimate the causal effect](figures/DAG_altitude.png)

Estimating correctly the effect $altitude \rightarrow fruit~removal$ implies conditioning on the *type of island*, since it is a common cause of altitude and fruit removal and its omition would bias our estimation.


## Mathematical version

Random effects and correlated islands remain as showed in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{altitude~i} + \gamma_{type~of~island} + \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
& \gamma \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      real beta_alt;
      // real beta_iso;
      // beta beta_NV;
      // beta beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      beta_alt ~ normal(0, 1);
      // beta_iso ~ normal(0, 1);
      // beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(4);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen1.rds')

```


## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive distributions showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      'beta_alt',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', 'beta_alt', 'TI', 'country', 'island', 
         'grid', 'plant'), FUN = 
         function(x) {
           posterior_pars[, grep(x, colnames(posterior_pars))]
         })

names(posterior_pars) <- c('alpha', 'beta_alt', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery

The function `compare_posterior` is used to compare estimated vs true parameter of the model.

```{r}
compare_posterior <- 
  function(post = posterior_pars$island, 
           real = islands_pars, 
           xlab = 'Islands', 
           ylab = 'Posterior mean', 
           main = 'Island parameters') {
    post <- 
      do.call('rbind', 
              lapply(post, FUN = 
                       function(x) {
                         tibble(li = quantile(x, 0), 
                                ls = quantile(x, 1), 
                                mu = mean(x))
                       }))
    post$x <- 1:nrow(post)
    post$real <- real
    
    plot(NULL, xlim = c(0, nrow(post)), ylim = c(-10, 10), 
         ylab = ylab, xlab = xlab, 
         main = main)
    post %$% 
      segments(y0 = li, y1 = ls, x0 = x)
    post %$%
      points(x = x, y = mu)
    post %$%
      points(x = x, y = real, pch = 16, col = 'red')
  }
```

**Random effects:**

```{r, fig.cap='Country parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```


**Main effect**

```{r, fig.cap='Effect of altitude on fruit removal. Density line indicate the posterior distribution, whereas the vertical red line the "true" parameter'}
plot(density(posterior_pars$beta_alt$beta_alt), 
     main = '', xlab = expression(beta['altitude']), 
     xlim = c(-4, 4))
abline(v = beta_alt, col = 'red', lwd = 2)
```

# S7. Effect type of island

![The red arrow indicates our estimand (i.e., the effect of the factor in green on the response in red), and orange factors indicate the adjustment set to correctly estimate the causal effect](figures/DAG_type_island.png)


Estimating correctly the effect $type of island \rightarrow fruit~removal$ implies not including any mediation path that could block the effect of our estimand. Thus, any additional factor should be included.

## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \gamma_{type~of~island} + \theta_{plant~id} +\\
& ~~~~~~~~~~~~~~~~~~ \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \gamma \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      //real beta_alt;
      // real beta_iso;
      // beta beta_NV;
      // beta beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      // beta_iso ~ normal(0, 1);
      // beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(4);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               // beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               // beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 2e3,
    thin = 5,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen2.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      #'beta_iso',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha',  'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effect of type of island on fruit removal. Density line indicate the posterior distribution, whereas the vertical red line the "true" parameter'}
compare_posterior(posterior_pars$TI,
                  type_island,
                  xlab = 'Type of island',
                  ylab = 'Posterior mean',
                  main = 'Type of island parameters')
```


# S8. Effect of island isolation

![The red arrow indicates our estimand (i.e., the effect of the factor in green on the response in red), and orange factors indicate the adjustment set to correctly estimate the causal effect](figures/DAG_isolation.png)

Estimating correctly the effect $isolation \rightarrow fruit~removal$ implies conditioning on the *type of island*, since it is a common cause of altitude and fruit removal and its omition would bias our estimation.


## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{isolation~i} + \gamma_{type~of~island} + \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
& \gamma \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      // real beta_alt;
      real beta_iso;
      // beta beta_NV;
      // beta beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      beta_iso ~ normal(0, 1);
      // beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(3);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial_logit(15, 
                               alpha +
                               // beta_alt * altitude +
                               beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]);
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               beta_iso * island_isolation +
                               // beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen3.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      'beta_iso',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', 'beta_iso', 'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', 'beta_iso', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameter. Red dot indicate the true value, whereas error bars and hollow dot indicate average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effect of island isolation on fruit removal. Density line indicate the posterior distribution, whereas the vertical red line the "true" parameter'}

beta_tot_isolation <- 
  beta_nativeV * (0.5) + 
  beta_bush * (0.25 * 0.5) + 
  beta_isolation # total effect of isolation

plot(density(posterior_pars$beta_iso$beta_iso), 
     main = '', xlab = expression(beta['isolation']), 
     xlim = c(-4, 4))
abline(v = beta_tot_isolation, col = 'red', lwd = 2)

```


# S9. Effect of bush cover

![The red arrow indicates our estimand (i.e., the effect of the factor in green on the response in red), and orange factors indicate the adjustment set to correctly estimate the causal effect](figures/DAG_bush.png)


Estimating correctly the effect $bush~cover \rightarrow fruit~removal$ implies conditioning on *native cover*, since it is a common cause of bush cover and fruit removal and its omition would bias our estimation.


## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{bush~cover~i} + \beta_{native~cover~i} + \theta_{plant~id} + \\
& ~~~~~~~~~~~~~~~~~~ \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      // real beta_alt;
      // real beta_iso;
      real beta_NV;
      real beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      // beta_iso ~ normal(0, 1);
      beta_NV ~ normal(0, 1);
      beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(3);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               // beta_alt * altitude +
                               //beta_iso * island_isolation +
                               beta_NV * native_cover +
                               beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               //beta_iso * island_isolation +
                               beta_NV * native_cover +
                               beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen4.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      #'beta_iso',
                      'beta_NV',
                      'beta_bush',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', #'beta_iso', 
           'beta_NV', 'beta_bush', 'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', #'beta_iso', 
                           'beta_NV', 'beta_bush', 'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution.'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution.'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effect of bush cover on fruit removal. Density line indicate the posterior distribution, whereas the vertical red line the "true" value of the parameter'}
plot(density(posterior_pars$beta_bush$beta_bush), 
     main = '', xlab = expression(beta['bush cover']), 
     xlim = c(-2, 2))
abline(v = beta_bush, col = 'red', lwd = 2)
```


# S10. Effect of native vegetation

![The red arrow indicates our estimand (i.e., the effect of the factor in green on the response in red), and orange factors indicate the adjustment set to correctly estimate the causal effect](figures/DAG_nativeV.png)


Estimating correctly the effect $native~vegetation \rightarrow fruit~removal$ implies conditioning on two factors that are common causes of our predictor and response variable. 

*native cover*, since it is a common cause of bush cover and fruit removal and its omition would bias our estimation.


## Mathematical version

Random effects and correlated islands remain as shown in the previous section.

$$
\begin{aligned}
&~~~~~~~~ \text{Fruits consumed}_{bush~i} \sim binomial(15,~p) \\
\\
& logit(p) = \alpha + \beta_{native~cover~i} + \beta_{isolation~i} +  \\
& ~~~~~~~~~~~~~~~~~~ \theta_{plant~id} + \phi_{grid~id} + \tau_{island~id} + \psi_{country~id} \\
& \\
& \alpha \sim \mathcal{N}(0, 1) \\
& \beta \sim \mathcal{N}(0, 1) \\
\end{aligned}
$$

## Stan code

```{r}
cat(file = 'generative_simulation.stan', 
    '
    functions{
    
      matrix GP_quadratic(matrix x, 
                          real eta, 
                          real rho, 
                          real delta) {
                          
                          int N = dims(x)[1];
                          matrix[N, N] K;
                          matrix[N, N] L_K;
                          
                          for (i in 1:(N-1)) {
                            K[i, i] = eta + delta;
                            for (j in (i+1):N) {
                              K[i, j] = eta * exp(-rho * square(x[i, j]));
                              K[j, i] = K[i, j];
                            }
                          }
                          
                          K[N, N] = eta + delta;
                          L_K = cholesky_decompose(K);
                          return L_K;
                          }
    }
    
    data {
      int N;
      int N_islands;
      int N_country;
      int N_plant;
      int N_grid;
      int N_type_island;
      // response
      array[N] int fruit_removal;
      // propulation effects
      array[N] int type_island;
      vector[N] altitude;
      vector[N] island_isolation;
      vector[N] native_cover;
      vector[N] bush_cover;
      // group level effects
      array[N] int islands_ID;
      array[N] int country_ID;
      array[N] int grid_ID;
      array[N] int plant_ID;
      // matrix of island distances (std)
      matrix[N_islands, N_islands] dist_islands;
    }
    
    parameters {
      
      // intercept
      real alpha;
      
      // population effects
      vector[N_type_island] TI;
      // real beta_alt;
      real beta_iso;
      real beta_NV;
      // real beta_bush;
    
      // group level effects
      // GP island
      vector[N_islands] z_islands;
      real<lower = 0> eta;
      real<lower = 0> rho;
      
      // country
      vector[N_country] z_country;
      real mu_country;
      real<lower = 0> sigma_country;
      
      // grid
      vector[N_grid] z_grid;
      real mu_grid;
      real<lower = 0> sigma_grid;
      
      // plant
      vector[N_plant] z_plant;
      real mu_plant;
      real<lower = 0> sigma_plant;
      
    }
    
    transformed parameters {
      
      // Population effects
      
      
      // group level effects
      // GP islands
      vector[N_islands] island;
      matrix[N_islands, N_islands] L_K_islands;
      L_K_islands = GP_quadratic(dist_islands,
                                 eta, 
                                 rho, 
                                 0.001);
      island = L_K_islands * z_islands;
      
      // country
      vector[N_country] country;
      country = mu_country + z_country * sigma_country;
      
      // grid
      vector[N_grid] grid;
      grid = mu_grid + z_grid * sigma_grid;
      
      // plant
      vector[N_plant] plant;
      plant = mu_plant + z_plant * sigma_plant;
    }
    
    model {
      
      // intercept and dispersion
      alpha ~ normal(0, 1);
      
      // Population effects
      TI ~ normal(0, 1);
      //beta_alt ~ normal(0, 1);
      beta_iso ~ normal(0, 1);
      beta_NV ~ normal(0, 1);
      // beta_bush ~ normal(0, 1);
      
      // GP islands
      eta ~ exponential(4);
      rho ~ exponential(1);
      z_islands ~ normal(0, 1);
      
      // country
      z_country ~ normal(0, 1);
      mu_country ~ normal(0, 0.5);
      sigma_country ~ exponential(1);
      
      // grid
      z_grid ~ normal(0, 1);
      mu_grid ~ normal(0, 0.5);
      sigma_grid ~ exponential(1);
      
      // plant
      z_plant ~ normal(0, 1);
      mu_plant ~ normal(0, 0.5);
      sigma_plant ~ exponential(1);
      
      fruit_removal ~ binomial(15, 
                               inv_logit(
                               alpha +
                               // beta_alt * altitude +
                               beta_iso * island_isolation +
                               beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    
    generated quantities {
      array[N] int ppcheck;
      
      ppcheck = binomial_rng(15, 
                             inv_logit(
                               alpha +
                               //beta_alt * altitude +
                               beta_iso * island_isolation +
                               beta_NV * native_cover +
                               // beta_bush * bush_cover +
                               TI[type_island] +
                               country[country_ID] +
                               island[islands_ID] +
                               grid[grid_ID] +
                               plant[plant_ID]
                               ));
    }
    ')
```

## Fitting the model

```{r, eval=FALSE}
file <- paste0(getwd(), '/generative_simulation.stan')
fit_gen_sim <- cmdstan_model(file, compile = T)

mod_gen_sim <- 
  fit_gen_sim$sample(
    data = dat,
    iter_warmup = 500, 
    iter_sampling = 1e3,
    thin = 3,
    chains = 4, 
    parallel_chains = 4,
    seed = 06231993
  )
```

```{r, echo=FALSE}

mod_gen_sim <- readRDS('mod_gen5.rds')

```

## Model diagnostics 

```{r, fig.cap='Bulk and tail effective sampling size (ess) of estimated parameters in the model (left). Posterior predictive simulations showing the quality of models fit (rigth).'}
par(mfrow = c(1, 2))
summary_mod_gen <- mod_gen_sim$summary()
mod_diagnostics(mod_gen_sim, summary_mod_gen)

ppcheck <- mod_gen_sim$draws('ppcheck', format = 'matrix')

plot(density(dat$fruit_removal), main = '', 
     xlab = 'Simulated fruit removal')
for (i in 1:200) lines(density(ppcheck[i, ]), lwd = 0.1)
lines(density(dat$fruit_removal), lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

## Posterior distributions

Extracting and formatting posterior distributions.

```{r, warning=FALSE}

posterior_pars <- 
  mod_gen_sim$draws(c('alpha', 
                      'beta_iso',
                      'beta_NV',
                      #'beta_bush',
                      'TI',
                      'country', 
                      'island', 
                      'grid', 
                      'plant'), 
                    format = 'df')


posterior_pars <- 
  lapply(c('alpha', 'beta_iso', 
           'beta_NV', #'beta_bush', 
           'TI', 
           'country', 'island', 
           'grid', 'plant'), FUN = 
           function(x) {
             posterior_pars[, grep(x, colnames(posterior_pars))]
           })

names(posterior_pars) <- c('alpha', 'beta_iso', 
                           'beta_NV', 
                           #'beta_bush', 
                           'TI', 
                           'country', 'island', 
                           'grid', 'plant')

```


## Parameters recovery


**Random effects:**

```{r, fig.cap='Country parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$country, 
                  country, 
                  xlab = 'Countries', 
                  ylab = 'Posterior mean', 
                  main = 'Country parameters')
```


```{r, fig.cap='Island parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$island, 
                  islands_pars, 
                  xlab = 'Islands', 
                  ylab = 'Posterior mean', 
                  main = 'Islands parameters')
```

```{r, fig.cap='Plant parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution'}

compare_posterior(posterior_pars$plant, 
                  plants, 
                  xlab = 'Plants', 
                  ylab = 'Posterior mean', 
                  main = 'Plant parameters')
```


```{r, fig.cap='Grid parameter. Red dots indicate the true value, whereas error bars and hollow dots indicate the average and 96% CI of the posterior distribution'}
compare_posterior(posterior_pars$grid, 
                  grid, 
                  xlab = 'Grid', 
                  ylab = 'Posterior mean', 
                  main = 'Grid parameters')
```

```{r, fig.cap='Gaussian process parameters'}
par(mfrow = c(1, 2))
plot(density(as.vector(mod_gen_sim$draws('rho', format = 'matrix'))), 
     main = '', xlab = expression(rho))
abline(v = rho, lwd = 2, col = 'red')

plot(density(as.vector(mod_gen_sim$draws('eta', format = 'matrix'))), 
     main = '', xlab = expression(eta))
abline(v = eta, lwd = 2, col = 'red')
par(mfrow = c(1, 1))
```

**Main effect**

```{r, fig.cap='Effects of island isolation (direct) and native cover (total) on fruit removal. Density line indicate the posterior distribution, whereas the vertical red line the "true" value of the parameter'}

par(mfrow = c(1, 2))
plot(density(posterior_pars$beta_iso$beta_iso), main = '', 
     xlab = expression(beta['island isolation']), 
     xlim = c(-4, 4))
abline(v = beta_isolation, lwd = 2, col = 'red')

plot(density(posterior_pars$beta_NV$beta_NV), main = '', 
     xlab = expression(beta['Native vegetation']), xlim = c(-4, 4))
abline(v = beta_nativeV, lwd = 2, col = 'red')
par(mfrow = c(1, 1))

```


# S11 Conclusion 

All models (see sections 6.6, 7.6, 8.6, 9.6 and 10.6) recovered the true parameters of the generative simulation. Indicating that they were well specified, are adequate to detect the target effects, and are ready to be used with the real data. 








